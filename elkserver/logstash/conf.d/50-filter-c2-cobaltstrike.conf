# Cobalt Strike C2 Log Parser
# Parses Cobalt Strike teamserver logs, beacon logs, and events

filter {
  # Process Cobalt Strike beacon logs
  # Compatible with official RedELK Filebeat field structure
  if [infra][log][type] == "rtops" and [c2][program] == "cobaltstrike" {

    # Parse main beacon log format
    if [c2][log][type] == "beacon" {
      grok {
        match => {
          "message" => "(?<cs.timestamp>%{MONTHNUM}/%{MONTHDAY} %{TIME}(?: UTC)?) \[%{DATA:cs.type}\] %{GREEDYDATA:cs.message}"
        }
      }

      # Parse beacon metadata from message
      if [cs.type] == "metadata" {
        grok {
          match => {
            "cs.message" => "beacon_%{DATA:cs.beacon_id} %{IP:cs.target_ip} %{DATA:cs.target_hostname} %{DATA:cs.target_username} %{DATA:cs.target_process} %{NUMBER:cs.target_pid}"
          }
        }

        mutate {
          add_field => {
            "beacon.id" => "%{cs.beacon_id}"
            "host.ip" => "%{cs.target_ip}"
            "host.hostname" => "%{cs.target_hostname}"
            "user.name" => "%{cs.target_username}"
            "process.name" => "%{cs.target_process}"
            "process.pid" => "%{cs.target_pid}"
          }
        }
      }

      # Parse beacon initial checkin
      if [cs.type] == "initial" {
        grok {
          match => {
            "cs.message" => "%{DATA:cs.beacon_id} beacon from %{IP:cs.target_ip} as %{DATA:cs.target_username}"
          }
        }
        mutate {
          add_field => {
            "beacon.id" => "%{cs.beacon_id}"
            "host.ip" => "%{cs.target_ip}"
            "user.name" => "%{cs.target_username}"
            "event.action" => "beacon_initial"
          }
        }
      }

      # Parse beacon commands
      if [cs.type] == "task" {
        grok {
          match => {
            "cs.message" => "%{DATA:cs.operator} tasked beacon_%{DATA:cs.beacon_id} %{GREEDYDATA:cs.command}"
          }
        }
        mutate {
          add_field => {
            "beacon.id" => "%{cs.beacon_id}"
            "user.name" => "%{cs.operator}"
            "process.command_line" => "%{cs.command}"
            "event.action" => "beacon_task"
          }
        }
      }

      # Parse beacon output
      if [cs.type] == "output" {
        mutate {
          add_field => {
            "event.action" => "beacon_output"
          }
        }
      }

      # Parse screenshot events
      if [cs.message] =~ /screenshot/ {
        grok {
          match => {
            "cs.message" => "screenshot from %{DATA:cs.beacon_id}"
          }
        }
        mutate {
          add_field => {
            "beacon.id" => "%{cs.beacon_id}"
            "event.action" => "screenshot"
            "file.type" => "screenshot"
          }
          add_tag => [ "screenshot" ]
        }
      }

      # Parse keystroke events
      if [cs.message] =~ /keylog/ {
        mutate {
          add_field => {
            "event.action" => "keylogger"
            "file.type" => "keystrokes"
          }
          add_tag => [ "keylogger" ]
        }
      }

      # Parse file download events
      if [cs.message] =~ /download/ {
        grok {
          match => {
            "cs.message" => "download %{DATA:file.path}"
          }
        }
        mutate {
          add_field => {
            "event.action" => "file_download"
            "file.type" => "download"
          }
          add_tag => [ "download" ]
        }
      }

      # Parse credential events
      if [cs.message] =~ /credentials|password|hash/ {
        mutate {
          add_field => {
            "event.action" => "credential_harvest"
          }
          add_tag => [ "credentials" ]
        }
      }
    }

    # Parse events.log format (join/leave)
    if [c2][log][type] == "events" {
      grok {
        match => {
          "message" => "(?<cs.timestamp>%{MONTHNUM}/%{MONTHDAY} %{TIME}(?: UTC)?) (?<cs.event_type>%{DATA}) from %{IP:source.ip}"
        }
      }

      if [cs.event_type] == "*** join" {
        mutate {
          add_field => {
            "event.action" => "operator_join"
            "event.type" => "connection"
          }
        }
      }

      if [cs.event_type] == "*** quit" or [cs.event_type] == "*** left" {
        mutate {
          add_field => {
            "event.action" => "operator_leave"
            "event.type" => "disconnection"
          }
        }
      }
    }

    # Parse weblog format
    if [c2][log][type] == "weblog" {
      grok {
        match => {
          "message" => "%{IPORHOST:source.ip} - - \[%{HTTPDATE:timestamp}\] \"%{WORD:http.request.method} %{URIPATH:url.path}(?:%{URIPARAM:url.query})? HTTP/%{NUMBER:http.version}\" %{NUMBER:http.response.status_code} %{NUMBER:http.response.body.bytes}(?: \"%{DATA:http.request.referrer}\" \"%{DATA:user_agent.original}\")?"
        }
      }

      date {
        match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
        target => "@timestamp"
      }

      mutate {
        convert => {
          "http.response.status_code" => "integer"
          "http.response.body.bytes" => "integer"
        }
      }
    }

    # Parse downloads.log
    if [c2][log][type] == "downloads" {
      grok {
        match => {
          "message" => "%{GREEDYDATA:file.path}"
        }
      }
      mutate {
        add_field => {
          "event.action" => "file_download"
          "file.type" => "download"
        }
        add_tag => [ "download" ]
      }
    }

    # Parse keystrokes.log
    if [c2][log][type] == "keystrokes" {
      mutate {
        add_field => {
          "event.action" => "keylogger"
          "file.type" => "keystrokes"
        }
        add_tag => [ "keylogger" ]
      }
    }

    # Parse screenshots.log
    if [c2][log][type] == "screenshots" {
      grok {
        match => {
          "message" => "%{DATA:file.name}"
        }
      }
      mutate {
        add_field => {
          "event.action" => "screenshot"
          "file.type" => "screenshot"
        }
        add_tag => [ "screenshot" ]
      }
    }

    # Parse IOCs
    if [cs.message] =~ /artifact|IOC|indicator/ {
      mutate {
        add_tag => [ "ioc" ]
        add_field => {
          "threat.indicator.type" => "artifact"
        }
      }
    }

    # Common enrichment for all CS logs
    mutate {
      add_field => {
        "event.module" => "cobaltstrike"
        "event.dataset" => "rtops"
        "agent.type" => "cobaltstrike"
        "c2.program" => "cobaltstrike"
        "infra.log_type" => "rtops"
      }
    }

    # Date parsing for CS timestamp
    if [cs.timestamp] {
      date {
        match => [ "cs.timestamp", "MM/dd HH:mm:ss", "MM/dd HH:mm:ss 'UTC'" ]
        target => "@timestamp"
        timezone => "UTC"
      }
    }

    # GeoIP enrichment for source IPs
    if [source.ip] {
      geoip {
        source => "source.ip"
        target => "source.geo"
      }
    }

    # Tag high-value activities
    if [cs.command] =~ /mimikatz|hashdump|dcsync|golden|silver|pth|pass-the|kerberoast|asreproast/i {
      mutate {
        add_tag => [ "high_value_activity", "credential_attack" ]
      }
    }

    if [cs.command] =~ /psexec|wmi|dcom|schtask|service/i {
      mutate {
        add_tag => [ "lateral_movement" ]
      }
    }

    if [cs.command] =~ /persist|registry|scheduled|service|wmi/i {
      mutate {
        add_tag => [ "persistence" ]
      }
    }
  }
}