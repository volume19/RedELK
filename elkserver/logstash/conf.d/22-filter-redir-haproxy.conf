# HAProxy Redirector Log Parser
# Parses HAProxy logs with RedELK custom format

filter {
  if [fields][infralogtype] == "redirtraffic" and [fields][redirprogram] == "haproxy" {

    grok {
      match => { "message" => "%{SYSLOGTIMESTAMP:timestamp} %{PROG:process.name}\[%{INT:process.pid}\]: %{IPORHOST:source.ip}:%{INT:source.port} \[%{GREEDYDATA:haproxy.accept_date}\] %{NOTSPACE:redir.frontend.name} %{NOTSPACE:redir.backend.name}/%{NOTSPACE:haproxy.server_name} %{INT:haproxy.time_request}/%{INT:haproxy.time_queue}/%{INT:haproxy.time_connect}/%{INT:haproxy.time_response}/%{INT:haproxy.time_duration} %{INT:http.response.status_code} %{INT:http.response.body.bytes} - - %{NOTSPACE:haproxy.termination_state} %{INT:haproxy.actconn}/%{INT:haproxy.feconn}/%{INT:haproxy.beconn}/%{INT:haproxy.srv_conn}/%{INT:haproxy.retries} %{INT:haproxy.srv_queue}/%{INT:haproxy.backend_queue} \"(?<http.request.method>\\S+) (?<url.original>\\S+)(?: HTTP/(?<http.version>[\\d\\.]+))?\" \"%{DATA:user_agent.original}\" \"%{DATA:http.request.headers.x-forwarded-for}\" \"%{DATA:http.request.headers.x-host}\" \"%{DATA:http.request.headers.host}\" \"%{DATA:http.request.headers.x-forwarded-proto}\"" }
    }

    date {
      match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
      target => "@timestamp"
    }

    # Parse X-Forwarded-For
    if [http.request.headers.x-forwarded-for] and [http.request.headers.x-forwarded-for] != "-" {
      mutate {
        split => { "http.request.headers.x-forwarded-for" => "," }
      }
      mutate {
        replace => { "source.ip" => "%{[http.request.headers.x-forwarded-for][0]}" }
      }
    }

    # GeoIP enrichment
    geoip {
      source => "source.ip"
      target => "source.geo"
    }

    # User agent parsing
    useragent {
      source => "user_agent.original"
      target => "user_agent"
    }

    mutate {
      add_field => {
        "infra.log_type" => "redirtraffic"
        "infra.log_subtype" => "haproxy"
        "event.module" => "redelk"
        "event.dataset" => "redirtraffic"
      }
      convert => {
        "http.response.status_code" => "integer"
        "http.response.body.bytes" => "integer"
        "haproxy.time_duration" => "integer"
        "haproxy.time_request" => "integer"
        "haproxy.time_response" => "integer"
      }
    }

    # HAProxy specific tags
    if [haproxy.termination_state] =~ /^[CcSsPpRr]/ {
      mutate { add_tag => [ "haproxy_error" ] }
    }

    # Slow request detection
    if [haproxy.time_duration] > 5000 {
      mutate { add_tag => [ "slow_request" ] }
    }

    # Suspicious user agent detection
    if [user_agent.original] =~ /curl|wget|python|powershell|nmap|nikto|sqlmap|dirbuster|burp|zap|acunetix/i {
      mutate { add_tag => [ "suspicious_useragent" ] }
    }
  }
}